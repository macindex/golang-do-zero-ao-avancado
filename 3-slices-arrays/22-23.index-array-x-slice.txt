Entender a diferença entre arrays e slices é o "divisor de 
águas" para quem está aprendendo Go. 
Embora pareçam similares à primeira vista, eles operam 
de formas muito distintas na memória.

Aqui está um mergulho profundo nesses conceitos:

1. Index (Índice)O índice é a posição de um elemento dentro 
de uma estrutura de dados sequencial. 
Em Go, assim como na maioria das linguagens modernas:Base 
Zero: O primeiro elemento está sempre no índice 
0.Acesso Direto: O acesso via índice tem complexidade 
constante, ou seja, O(1).
Segurança: Go não permite índices negativos e causa um 
panic se você tentar acessar um índice fora do limite 
(out of bounds).

2. Array
Um Array em Go é uma estrutura de tamanho fixo. O tamanho 
faz parte do tipo da variável.

Tamanho Imutável: Um [3]int é um tipo completamente diferente 
de um [4]int. Você não pode redimensioná-lo.

Valor, não Referência: Diferente de Java ou C#, arrays em 
Go são valores. Se você passar um array para uma função, 
Go criará uma cópia completa de todos os elementos.

Alocação Contígua: Todos os elementos são colocados lado 
a lado na memória.

var a [3]string
a[0] = "Go"
a[1] = "é"
a[2] = "Rápido"

3. Slice (Fatia)
O Slice é o que usamos no dia a dia. Ele não armazena dados por si só; ele é uma janela ou descrição para um array subjacente (underlying array).

A Estrutura Interna de um Slice
Internamente, um slice é uma struct composta por três 
campos:

Ponteiro: O endereço de memória onde começa o primeiro 
elemento (dentro de um array).

Length (Tamanho): Quantos elementos o slice contém atualmente.

Capacity (Capacidade): Quantos elementos existem no array 
subjacente a partir do início do slice.

Por que usar Slices?
Dinâmicos: Você pode adicionar elementos usando a função append().

Referência: Ao passar um slice para uma função, você está 
passando apenas a "descrição" (ponteiro, tam, cap), o que 
é extremamente eficiente em termos de memória.

Comparativo: Array vs. Slice
Característica  Array                       Slice
Definição       [5]int (tamanho fixo)       []int (sem tamanho no tipo)
Memória         Aloca os dados diretamente  Aponta para um array subjacente
Flexibilidade   Rígido                      Dinâmico (cresce com append)
Uso comum       Buffer de tamanho fixo,     Quase tudo (listas, coleções) 
                criptografia

O Comportamento do append e Alocação
Quando você usa append em um slice e ele atinge o limite 
da sua capacidade, Go faz o seguinte nos bastidores:

Cria um novo array subjacente maior (geralmente o dobro do 
tamanho).

Copia os elementos do array antigo para o novo.

Atualiza o ponteiro do slice para o novo array.

Dica de Performance: Se você sabe quantos elementos vai 
precisar, use make([]int, len, cap) para pré-alocar a 
capacidade e evitar cópias desnecessárias de memória.

-
func main() {
	var listaToda = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
	segundaLista := listaToda[:3]

	
	fmt.Println(segundaLista)
}
// Aqui estamos capturando os 3 primeiros itens

func main() {
	var listaToda = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
	segundaLista := listaToda[:3]
    terceiraLista := listaToda[4:]
	
	fmt.Println(segundaLista)
    fmt.Println(terceiraLista)
}

func main() {
	var listaToda = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
	segundaLista := listaToda[:3]
    terceiraLista := listaToda[4:]
	ultimoItem := listaToda[len(listaToda)-1:]
	fmt.Println(segundaLista)
    fmt.Println(terceiraLista)
}

-

// Isso é um Array (tamanho definido)
arr := [3]string{"Go", "Python", "C"}

// Isso é um Slice (tamanho oculto)
slc := []string{"Go", "Python", "C"}

func main() {
	var listaToda = []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}
   fmt.Printf("%T", listaToda)
}
// vai imprimir int 
// Logo iniciou []int é slice iniciou [10]int é array, array tem mais performance 

