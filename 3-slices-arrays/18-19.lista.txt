Agrupamento de dados e estrutura 
de dados. 

Em Go, o conceito de "listas" é abordado de forma distinta 
de outras linguagens. Embora existam listas ligadas na 
biblioteca padrão, o dia a dia do desenvolvedor é dominado 
pelos Slices, que são estruturas muito mais eficientes e 
versáteis para manipular coleções de dados.

Aqui está uma análise aprofundada das formas de trabalhar 
com coleções em Go:

1. Arrays vs. Slices (O coração das listas)
Para entender listas em Go, é fundamental diferenciar 
estas duas estruturas:

Arrays: Têm tamanho fixo definido na declaração e fazem 
parte do seu tipo (ex: [3]int é um tipo diferente de [5]int).

Slices: São segmentos dinâmicos de um array, funcionando 
como "janelas" que podem crescer ou diminuir. 
É a estrutura recomendada para criar código funcional e 
escalável.

2. Anatomia de um Slice
Um slice é composto por três componentes internos:

Ponteiro: Aponta para o primeiro elemento do array subjacente 
acessível pelo slice.

Tamanho (Length): O número de elementos que o slice contém 
no momento.

Capacidade (Capacity): O número total de elementos no array 
subjacente, a partir do início do slice.

3. Manipulação e Crescimento
Diferente do Java ou Python, onde você apenas adiciona itens, 
em Go você utiliza a função built-in append:

transacoes := []float64{100.50, 200.00}
// Adicionando um novo elemento
transacoes = append(transacoes, 50.75)

Alocação Dinâmica: Se a capacidade atual não for suficiente 
para um novo item, o Go aloca automaticamente um novo 
array maior e copia os elementos, garantindo a escalabilidade 
do sistema.

Criação com make: Para otimizar a performance, especialmente 
em sistemas bancários, você pode pré-alocar o espaço necessário: 
s := make([]int, tamanho, capacidade).

4. A Função copy e Fatiamento
Go permite criar sub-listas de forma extremamente 
performática através do fatiamento (s[baixo:alto]), que 
não copia os dados, apenas cria um novo ponteiro para o 
mesmo array.

Segurança: Para evitar que alterações na sub-lista afetem 
a lista original, utiliza-se a função copy() para duplicar 
os dados de forma independente.

5. Listas Ligadas (container/list)Para cenários muito 
específicos onde você precisa de inserções e remoções 
frequentes no meio da coleção com custo constante O(1), 
o Go oferece o pacote container/list.
Uso: É uma lista duplamente ligada que armazena tipos any 
(interface vazia).
Desvantagem: É menos performática para acesso aleatório 
e menos amigável ao cache da CPU do que os slices.

Boas Práticas e Filosofia
Evite Arrays Globais: Prefira passar slices para funções, 
pois eles são passados por referência (ponteiro), o que 
é mais eficiente em termos de memória.

Nil Slices: Um slice declarado sem inicialização 
(var s []int) tem valor nil. 
Ele é perfeitamente funcional para o append, facilitando 
o tratamento de casos onde a lista começa vazia.

Tradução de Requisitos: Ao projetar sistemas de alta 
performance, a escolha correta entre pré-alocação com 
make ou crescimento dinâmico com append reflete uma 
abordagem de código manutenível e eficiente.

-
func main(){
    var lista := []int{4, 9, 6, 7}
    fmt.Println("Lista: ", lista)
}

func main(){
    var lista := []int{4, 9, 6, 7}
    fmt.Println("Lista: ", lista)
    fmt.Println("Lista: ", lista[0])
    fmt.Println("Lista: ", lista[1])
    fmt.Println("Lista: ", lista[2])
}

func main(){
    var lista := []int{4, 9, 6, 7}
    fmt.Println("Lista: ", lista)
    fmt.Println("Lista: ", lista[0])
    fmt.Println("Lista: ", lista[1])
    fmt.Println("Lista: ", lista[2])
    fmt.Println("Tamanho da lista: ", len(lista))
}

func main(){
    var lista := []int{4, 9, 6, 7}
    fmt.Println("Lista: ", lista)
    fmt.Println("Lista: ", lista[0])
    fmt.Println("Lista: ", lista[1])
    fmt.Println("Lista: ", lista[2])
    fmt.Println("Tamanho da lista: ", len(lista))
    fmt.Println("Lista pos3: ", lista[5])
}


