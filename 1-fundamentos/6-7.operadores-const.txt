Os operadores em Go são os símbolos que instruem o compilador a realizar 
manipulações matemáticas ou lógicas específicas. 
Embora a sintaxe seja familiar para quem vem do C ou Java, Go introduz algumas 
restrições de segurança importantes para evitar bugs comuns.

Aqui está uma análise detalhada dividida por categorias:

1. Operadores Aritméticos

Go suporta as operações matemáticas padrão. Um detalhe crucial: não existe promoção 
automática de tipos. Você não pode somar um int8 com um int32 sem converter um 
deles.
Operador                Descrição                       Exemplo
+                       Soma (também concatena strings) 5 + 5 ou "Go" + "Lang"
-Subtração              10 - 2
*                       Multiplicação                   3 * 4   
/                       Divisão                         10 / 3 (Resultado é 3 se forem inteiros)
%                       Resto da divisão (Módulo)       10 % 3 (Resultado é 1)

Incremento e Decremento (++ e --)
Em Go, i++ e i-- são instruções (statements) e não expressões.

Não existe pré-incremento: ++i é inválido.

Não pode ser usado em atribuições: x = i++ resulta em erro de compilação. 
Isso elimina a ambiguidade comum em outras linguagens.

2. Operadores Relacionais (Comparação)
Sempre retornam um valor booleano (true ou false). Em Go, você só pode comparar 
variáveis do mesmo tipo.

== (Igual a)

!= (Diferente de)

< , >, <=, >= (Menor, Maior, Menor ou igual, Maior ou igual)

3. Operadores Lógicos
Usados principalmente em estruturas condicionais (if, for). Go utiliza curto-circuito: se o resultado já puder ser determinado pela primeira parte da expressão, a segunda não é avaliada.

&& (AND): Retorna true se ambos forem verdadeiros.

|| (OR): Retorna true se pelo menos um for verdadeiro.

! (NOT): Inverte o valor booleano.

4. Operadores Bitwise (Bit a Bit)
Para manipulação de baixo nível, Go oferece operadores que trabalham diretamente 
nos bits dos números inteiros.

& (AND): Compara cada bit; resulta em 1 se ambos forem 1.

| (OR): Resulta em 1 se pelo menos um bit for 1.

^ (XOR): Resulta em 1 se os bits forem diferentes.

&^ (Bit Clear): Um operador único do Go. z = x &^ y limpa os bits em x que estão definidos como 1 em y.

<< e >>: Deslocamento de bits para esquerda ou direita (multiplica ou divide por potências de 2).

5. Operadores de Atribuição
Além do tradicional =, Go possui operadores compostos que facilitam a escrita:

+=, -=, *=, /=, %=

&=, |=, ^=, <<=, >>=

E, claro, o Operador de Atribuição Curta (:=), que discutimos no tópico de variáveis, usado para declarar e inicializar variáveis locais simultaneamente.

Biblioteca reflect: traz o tipo da variável que se está utilizando


6. Operadores de Endereço (Ponteiros)
Como Go permite manipulação de ponteiros (embora sem a aritmética complexa de C), dois operadores são fundamentais:

&: Gera o endereço de memória de uma variável.

*: Atua como um ponteiro para um endereço ou para "desreferenciar" (acessar o valor contido naquele endereço).

Precedência de Operadores
Go possui uma hierarquia de precedência simplificada em comparação ao C++. Quando operadores têm a mesma precedência, a avaliação ocorre da esquerda para a direita.

1. * / % << >> & &^ (Alta precedência)

2. + - | ^

3. == != < <= > >=

4. &&

5. || (Baixa precedência)

Exemplo de cuidado: x := 5 + 2 * 3 resultará em 11, pois a multiplicação tem 
precedência sobre a soma. Use parênteses () para forçar a clareza.


--------------------------------------------

CONST 

As constantes em Go são valores que permanecem fixos durante toda a execução do 
programa. Embora pareçam simples "variáveis que não mudam", elas possuem 
características únicas no compilador Go que as tornam extremamente eficientes e 
flexíveis, especialmente devido ao conceito de Constantes Não Tipadas.

1. Declaração e Tipos
Constantes são criadas com a palavra-chave const. Elas podem ser declaradas de 
duas formas:

Tipadas: Comportam-se de forma rígida, como variáveis comuns.

Go
const Pi float64 = 3.14159

Não Tipadas: Esta é a "mágica" do Go. Uma constante sem tipo definido possui 
precisão arbitrária e só assume um tipo quando é usada em um contexto que o exige.

Go
const Limite = 100 // Não tipada (idealmente um int, mas pode ser float se necessário)

2. O Poder da Precisão Arbitrária
Diferente das variáveis, constantes numéricas não tipadas em Go podem representar 
números com uma precisão muito maior do que os tipos primitivos (int64, float64) 
permitem.

O compilador mantém essas constantes com pelo menos 256 bits de precisão. 
Isso permite operações matemáticas complexas em tempo de compilação sem perda de 
dados antes da atribuição final.

Go
const Gigante = 1 << 100 // Um número imenso que não caberia em um int64
const Resultado = Gigante >> 95 // Resultado é 32 (cabe em um int)

3. IOTA: O Gerador de Enumerações
Go não possui uma palavra-chave enum. Em vez disso, utiliza o identificador especial 
iota, que simplifica a criação de sequências de números relacionados. 
O iota começa em 0 e incrementa a cada linha em um bloco const.

Go
const (
    Domingo = iota // 0
    Segunda        // 1
    Terca          // 2
)


Uso avançado do IOTA (Bitmask)
O iota é frequentemente usado para definir sinalizadores de bits (flags), combinando-o 
com operadores de deslocamento (<<):

Go
const (
    Ler = 1 << iota   // 1  (0001)
    Escrever          // 2  (0010)
    Executar          // 4  (0100)
)

4. Regras de Ouro das Constantes
Para entender o comportamento interno, lembre-se destas restrições:

Apenas Valores de Tempo de Compilação: O valor de uma constante deve ser 
conhecido pelo compilador. Você não pode atribuir o resultado de uma função a uma 
constante.

const tempo = time.Now() // Erro! (O tempo só é conhecido na execução).

Imutabilidade: Tentar alterar uma constante resultará em erro de compilação.

Sem Operador Curto: O operador := nunca é usado com constantes. Use sempre const.

5. Constantes vs Variáveis: Quando usar?

Característica              Constante (const)                   Variável (var / :=)
Alocação                    Geralmente inserida diretamente     Alocada na Stack ou Heap
                            no código (inline)
Performance                 Ligeiramente mais rápida            Padrão
                            (otimização do compilador)
Flexibilidade               Alta (se não tipada)                Baixa (tipo fixo após declaração)
Endereço                    Não possui endereço de memória (&)  Possui endereço de memória

Nota: Como constantes não têm endereço de memória físico acessível, você não pode 
criar um ponteiro para uma constante.

Exemplo Prático de Flexibilidade
Graças às constantes não tipadas, você pode fazer isso sem conversões chatas:

Go
const Coeficiente = 2 // Não tipada

var i int = 10 * Coeficiente     // Funciona como int
var f float64 = 5.5 * Coeficiente // Funciona como float64

Isso evita a necessidade de escrever float64(Coeficiente) repetidamente, mantendo o código limpo e seguro.

Gostaria que eu demonstrasse como usar constantes e iota para criar uma biblioteca simples de conversão de unidades (como KB, MB, GB)?


