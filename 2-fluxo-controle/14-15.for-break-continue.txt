Em Go, o controle de fluxo através de laços de repetição 
é propositalmente minimalista. Diferente de outras linguagens 
que possuem while, do-while e for, Go utiliza apenas a 
palavra-chave for para todos os cenários de iteração.

Aqui está uma análise detalhada de como utilizar o for e 
seus comandos de interrupção:

1. O Laço for e suas Variantes
A estrutura do for em Go não utiliza parênteses ao redor 
das condições, seguindo a mesma filosofia do if.

For Clássico (Três componentes): Composto por inicialização, 
condição e pós-processamento.

for i := 0; i < 10; i++ {
    fmt.Println(i)
}

For como "While": Se você omitir a inicialização e o 
pós-processamento, o for se comporta exatamente como um 
while.

n := 1
for n < 5 {
    n *= 2
}

For Infinito: Omitindo todos os componentes, você cria um 
loop que roda para sempre até ser interrompido manualmente.

for {
    // executa eternamente
}

2. O Comando break
O break é utilizado para encerrar a execução do laço 
imediatamente. Em um ambiente bancário ou de sistemas de 
missão crítica, ele é essencial para interromper processamentos 
assim que um erro ou uma condição de parada é detectada.

Uso Comum: Sair de um loop infinito quando uma condição é 
atingida.

Escopo: Ele encerra apenas o laço mais interno onde está 
inserido.

for i := 0; i < 100; i++ {
    if i == 50 {
        break // O loop para aqui e sai para a próxima linha fora do for
    }
}

3. O Comando continue
Diferente do break, o continue não para o laço, mas interrompe 
apenas a iteração atual. Ele salta diretamente para o 
pós-processamento (o i++) e inicia a próxima volta do 
loop.

Aplicação: Útil para ignorar dados inválidos ou casos 
específicos sem encerrar todo o processo.

Filosofia Go: Ajuda a manter o "Happy Path" alinhado à 
esquerda, evitando grandes blocos if/else dentro do 
laço.

for i := 1; i <= 5; i++ {
    if i%2 == 0 {
        continue // Pula os números pares
    }
    fmt.Println(i) // Só imprime ímpares: 1, 3, 5
}

4. Break com Rótulos (Labels)
Em Go, quando você tem laços aninhados (um for dentro de 
outro), o break padrão só sai do laço interno. 
Para sair de todos os laços de uma vez, utilizamos Labels.

OuterLoop:
for i := 0; i < 5; i++ {
    for j := 0; j < 5; j++ {
        if i*j > 10 {
            break OuterLoop // Encerra ambos os laços imediatamente
        }
    }
}

5. Iteração com range
Para coleções (arrays, slices, maps), o Go oferece o range, 
que facilita a iteração fornecendo o índice e o valor.

nomes := []string{"Sam", "Frodo", "Gandalf"}
for indice, nome := range nomes {
    fmt.Printf("Índice: %d, Nome: %s\n", indice, nome)
}

Resumo de Boas Práticas
Simplicidade: Use o break para evitar processamento 
desnecessário após atingir um objetivo.

Legibilidade: Utilize o continue para filtrar itens e 
manter a lógica principal do laço limpa e sem 
aninhamentos excessivos.

Performance: Em sistemas de alta performance, evite laços 
infinitos sem uma estratégia clara de saída ou um time.
Sleep se estiver monitorando recursos externos.

func main() {
    for i := 0; i <= 10; i++ {
        fmt.Println(i)
    }
}

--------------------------------------------------------

func main() {
texto := "palavra"
fmt.Println("Quantidade: ", len(texto)) 
    for i := 0; i < len(texto); i++ {
        if string(texto[i] == "r"){
            break
        }
        fmt.Println(string(texto[i]))
    }
}


func main() {
texto := "palavra"
fmt.Println("Quantidade: ", len(texto)) 
    for i := 0; i < len(texto); i++ {
        if string(texto[i] == "r"){
            continue
        }
        fmt.Println(string(texto[i]))
    }
}


